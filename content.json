{"meta":{"title":"Dajitui's blog","subtitle":"Your magic is mine!","description":null,"author":"Dajitui","url":"http://blog.dajitui.fun","root":"/"},"pages":[{"title":"关于lzb","date":"2017-03-28T03:43:32.000Z","updated":"2017-03-28T03:39:19.394Z","comments":true,"path":"about/index.html","permalink":"http://blog.dajitui.fun/about/index.html","excerpt":"","text":"QAQ"}],"posts":[{"title":"虚拟内存","slug":"Virtual-Memory","date":"2017-11-26T13:09:12.000Z","updated":"2019-04-23T13:52:28.278Z","comments":true,"path":"2017/11/Virtual-Memory/","link":"","permalink":"http://blog.dajitui.fun/2017/11/Virtual-Memory/","excerpt":"","text":"虚拟内存是操作系统对主存、磁盘I/O设备的抽象表示。抽象的目的主要有以下几点： 将主存看作硬盘的高速缓存，并根据需要在硬盘和主存之间传送数据 为每个进程提供了一个大的、一致的、私有的地址空间，简化程序对内存的管理 保护每个进程的地址空间不被其他进程破坏 下图是单个Linux进程看到的虚拟地址空间。 事实上，这个时候，是有很多个进程同时运行在操作系统上。主存可能是这样子的： 上图，一开始加载了1、2、3三个程序，程序2运行结束产生了两个20k空闲，这时候启动了程序4，但是程序4需要的内存是25k，只能把程序3挪一下，合并两个20k，产生40k的空闲，然后将程序4加载到内存。分时系统，如果直接使用内存条的物理地址，将会非常麻烦。 假设进程1占据了0-1000号地址，进程2占据了1001-2100号地址，两个进程都有mov eax,ds:[100] ,把寄存器中的值写入地址是100的内存中。如果不做任何处理，两个进程会把值写入同一个地址，值会被覆盖。或者在装载程序的时候，把程序2的指令修改成mov eax,ds:[1100]，这个也是非常困难的。 所以操作系统提供了抽象，程序运行的时候，操作的都是逻辑地址，逻辑地址和物理地址的映射，由内存管理单元(MMU)维护。进程让cpu执行的指令里面，操作的都是逻辑地址。 内存地址的问题解决后，又出现了的问题，程序太大怎么办？操作系统同时运行多个程序，不可能将运行的程序全部加载到内存中。为了避免互相伤害。操作系统会对程序进行分块装入。 这样做的理论依据是局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通俗来说就是，执行了一条指令，马上又会执行这条指令，访问了某个地址上的数据，很快又会访问这个数据和附近的数据。 当程序装载的时候，会给进程分配一个页表（每页4K）讲逻辑地址和物理地址映射起来。每页会有一个有效位，如果设置了有效位，那么地址字段就表示DRAM中有相应的物理页起始位置，如果没有设置，但是有值，说明这个地址指向磁盘上的起始位置，如果，没有设置，也没有值，表示这个虚拟页面还未被分配。 比如，当要执行 MOV (0x560) EAX，这个指令，把地址是0x560中的值取出来放到EAX寄存器中。CPU接收到0x560这个地址，先进行拆分，6位页号，12位偏移量，获取页号0x00和偏移量0x560，然后根据页号获取物理地址页的基地址，再加上偏移量，得到物理地址，然后读取数据。中间这个计算过程由MMU完成。 当程序开始执行，执行到某一页，发现没有对应的物理地址的时候，就发生了缺页。比如CPU执行了mov [0x560] eax，把0x560中的值读出来写到EAX寄存器中，但是0x560 的值还不在内存当中。 设置缺页中断 (page fault) 缺页中断处理程序读取磁盘（这个过程cpu可能会去干其它事情） 选定一个牺牲页（先选一个空闲的物理页，如果满了，执行页面置换算法，选一个不太用的牺牲掉） 修改页表 重新开始执行 mov [0x560] eax 每个进程都要有一个页表，进程控制块PCB有指向页表的指针，一个进程不能访问另一个进程的地址。页表的访问需要非常快，所以会有一个硬件缓存， 转换缓冲区（TLB）。还有，页表本身可能非常大。比如32位的操作系统，支持4G(2^32)大小的逻辑地址空间。如果每一页4K(2^12)，那么可以有1百万个条目(2^32/2^12)。假设每个条目4B，那么每个进程需要4MB的物理地址空间来存储页表本身。所以又有几种技术，来减小页表本身的大小，多级页表，哈希页表，反向页表等。 内存总是有限的，不可能一直从硬盘读取数据写入到内存中，这种时候，需要进行页面置换。在发生缺页的时候，会进行页面置换。做web开发的时候，redis缓存什么的，也会需要置换。介绍一种算法LRU，最近最少使用。 因为LRU算法硬件很难实现，所以硬件一般用的是效果和LRU差不多的clock算法。 每个页加一个引用位, 默认值为0，无论读还是写，都置为1 把所有的页组成一个循环队列 选择淘汰页的时候，扫描引用位， 如果是1则改为0（相当于再给该页面一次存活的机会）， 并扫描下一个；如果该引用位是0， 则淘汰该页， 换入新的页面 用分页管理内存，还是有一些问题，用户视角的内存和实际物理内存分离。用户无法将内存看做一个线性字节数组。对用户来说，内存最好是这样的。这个用户可以理解为JVM。 分段就是这种支持用户视角的内存管理方案。 最后，就是段页结合，让分段面向用户，地址指明了段名和段内偏移。让分页面向硬件，对用户透明。先根据段找到页，再找到物理内存地址。","categories":[{"name":"Operating System","slug":"Operating-System","permalink":"http://blog.dajitui.fun/categories/Operating-System/"}],"tags":[{"name":"Operating System","slug":"Operating-System","permalink":"http://blog.dajitui.fun/tags/Operating-System/"},{"name":"Virtual Memory","slug":"Virtual-Memory","permalink":"http://blog.dajitui.fun/tags/Virtual-Memory/"}]},{"title":"哥尼斯堡七桥问题","slug":"seven-bridges-problem","date":"2017-04-05T18:57:12.000Z","updated":"2019-04-23T13:51:39.606Z","comments":true,"path":"2017/04/seven-bridges-problem/","link":"","permalink":"http://blog.dajitui.fun/2017/04/seven-bridges-problem/","excerpt":"","text":"柯尼斯堡，今日俄罗斯加里宁格勒，哲学家康德的故乡。柯尼斯堡曾经是东普鲁士首府，二战之后割让给了俄国。要是希特勒不作死，这块土地现在应该还是德国的。 这座城市被河流分割成了4块陆地。人们为了连接这些陆地，建了7座桥。 现在，需要走遍这7座桥。但是，必须遵守以下条件： 走过的桥不能走第二次 可以多次经过同一块陆地 可以以任意陆地为起点 不需要回到起点 数学家莱昂哈德·欧拉(Leonhard Euler,1707-1783)已经将这个问题作为一笔画问题解决。这就是图论的起源。 首先把七桥简化。用圆圈来表示陆地1、2、3、4，称为“顶点(vertex)”，用顶点之间的连线来表示桥a、b、c、d、e、f、g，为“边(edge)”，这种连接方式就是“图(graph)”。 然后，顶点所关联的边数，也就是每块陆地连接的桥数，称为该顶点的度数。 陆地0的度数3 陆地1的度数5 陆地2的度数3 陆地3的度数3 接每走过一个桥，桥相连的两个顶点的度数就要减一。因为可以从任意起点开始走，所以不关心具体从哪里开始，也不需要关心每个顶点经过几次，只要关注顶点的度数是如何变化的。 下来开始走，出发时，顶点的度数减1，途中经过每一个顶点时，该顶点的度数减2，因为每通过一个顶点，必须有2条边，一条作为入口，一条作为出口。最后到达终点时，终点度数减一。 如果所有的边都走到，那么最后所有顶点的度数都变为0. 当起点和终点相同的时候，图中所有的顶点，都应该是偶数度数。因为起点一开始减1，结束的时候减1，其它顶点，每走过一次减2. 当起点和终点不相同时，必须有2两个顶点时奇数，这两个顶点作为起点和终点，其它顶点是偶数。 所以如果按照规则，走过的桥不能走第二次，且必须走完所有的桥，必须让所有的顶点的度数都变为0，需要满足“所有大陆连接的桥的数量都是偶数，或者2个大陆连接的桥的数量是奇数，其余为偶数”。但实际情况是，所有大陆连接的桥的数量都是奇数。 最后，证明此条件下，不能走遍哥尼斯堡七桥。 哥尼斯堡问题中蕴含着一种思维方式。在观察各个顶点的度数时，重点并不在度数本身，而是“数的奇偶性(parity)”。途中每通过一次顶点，就要减少2个度数，所以顶点的度数必须是2的倍数。 下面是代码部分。因为计算机没有欧拉那么机智，所以只能一条一条找，穷举所有最长的一笔画路径。 这个图是多重图，可以用邻接表这种数据结构来表达。需要知道顶点的个数，和边的个数，以及每条边连接的是哪两个顶点。 七桥问题中，因为 有4个顶点，7条边。七条边从a-g分别为，0-1,0-1,0-3,1-3,1-2,1-2,2-3. 遍历出所有的不重复的最长路径，深度优先搜索。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360package me.lzb.example.graph;import java.util.*;/** * 遍历无向图的所有最长一笔画 * 深度优先，达到最深时，后退，继续搜索另一条路径 * Created by LZB on 2017/4/8. */public class Graph &#123; /** * 换行符 */ private static final String NEWLINE = System.getProperty(\"line.separator\"); /** * 路径分割符号 */ private static final String PATH_SEPARATOR = \"-&gt;\"; /** * 顶点数目 */ private int vertexCount; /** * 边的数目 */ private int edgeCount; /** * 出现过路径的最长变数 * 如果等于总边数，说明存在欧拉路径 */ int maxEdge = 0; /** * 顶点数组，每个list是与顶点关联的所有边 */ private LinkedList&lt;Edge&gt;[] edgeList; /** * 边 */ private class Edge &#123; /** * 边的id */ int id; /** * 是否被正向搜索 */ boolean isSearched; /** * 顶点v */ int v; /** * 顶点b */ int w; /** * 保存回滚操作中，被回滚的的路径方向，以及，前提路径 * 因为在不同级别的回滚中，可能会有多条临时路径，所以用list存放 * 顶点-&gt;顶点:路径id-&gt;路径id-&gt;路径id * 1-&gt;2:0-&gt;1-&gt;2 */ ArrayList&lt;String&gt; to = new ArrayList&lt;&gt;(); /** * 构造函数 * @param v 顶点v * @param w 顶点w */ public Edge(int v, int w) &#123; this.v = v; this.w = w; isSearched = false; id = edgeCount; &#125; /** * 在当前前提路径下，是否有 * @param v0 出发顶点 * @param P 前提路径 * @return true false */ public boolean isFrom(int v0, String P) &#123; return isTheSameTo(v0, getAnotherV(v0), P); &#125; /** * 临时路径是否相同 * @param v0 出发顶点 * @param v1 到达顶点 * @param p 前提路径 * @return true false */ public boolean isTheSameTo(int v0, int v1, String p) &#123; if (to.size() == 0) &#123; return false; &#125; String ss = v0 + PATH_SEPARATOR + v1 + \":\" + p; for (String s : to) &#123; if (ss.equals(s)) &#123; return true; &#125; &#125; return false; &#125; /** * 删除临时路径 * @param v0 出发顶点 * @param v1 到达顶点 * @param p 前提路径 */ public void removeTo(int v0, int v1, String p) &#123; if (to.size() == 0) &#123; return; &#125; String ss = v0 + PATH_SEPARATOR + v1 + \":\" + p; for (Iterator&lt;String&gt; iterator = to.iterator(); iterator.hasNext(); ) &#123; String s = iterator.next(); if (ss.equals(s)) &#123; iterator.remove(); return; &#125; &#125; &#125; /** * 增加临时路径 * @param v0 出发顶点 * @param v1 到达顶点 * @param p 前提路径 */ public void addTo(int v0, int v1, String p) &#123; String ss = v0 + PATH_SEPARATOR + v1 + \":\" + p; for (String s : to) &#123; if (ss.equals(s)) &#123; return; &#125; &#125; to.add(ss); &#125; /** * 获取边的另外一条顶点 * @param vertex * @return */ public int getAnotherV(int vertex) &#123; if (vertex == v) &#123; return w; &#125; else &#123; return v; &#125; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Edge c = (Edge) obj; return this.id == c.id; &#125; @Override public int hashCode() &#123; return id; &#125; &#125; /** * 构造函数 * @param vertexNum 顶点总数 * @param edgeCount 边的总数 */ public Graph(int vertexNum, int edgeCount) &#123; this.vertexCount = vertexNum; this.edgeCount = 0; edgeList = new LinkedList[edgeCount]; for (int i = 0; i &lt; edgeCount; i++) &#123; edgeList[i] = new LinkedList&lt;&gt;(); &#125; &#125; public void addEdge(int v1, int v2) &#123; Edge c = new Edge(v2, v1); edgeList[v1].add(c); edgeList[v2].add(c); edgeCount++; &#125; public void addEdge(int[][] edgeArray) &#123; for (int i = 0; i &lt; edgeArray.length; i++) &#123; addEdge(edgeArray[i][0], edgeArray[i][1]); &#125; &#125; public String toString() &#123; StringBuilder s = new StringBuilder(); s.append(vertexCount + \" vertices, \" + edgeCount + \" edges \" + NEWLINE); for (int v = 0; v &lt; vertexCount; v++) &#123; s.append(v + \": \"); for (Edge w : edgeList[v]) &#123; s.append(w.getAnotherV(v) + \" \"); &#125; s.append(NEWLINE); &#125; return s.toString(); &#125; /** * 更新出现过路径的最长边数 * @param a */ private void updateMax(int a) &#123; if (a &gt; maxEdge) &#123; maxEdge = a; &#125; &#125; public boolean isEuler() &#123; int start = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(start); //TODO 退出递归的条件 try &#123; search(start, start, stack, new Stack&lt;&gt;()); &#125;catch (EmptyStackException e)&#123; &#125; System.out.println(\"最长边数：\" + maxEdge); return maxEdge == edgeCount; &#125; /** * 正向搜索 * 传进去一个节点，顺着一条没有搜索过的边找到下一个节点。当搜索到死路时，回滚 * @param v 当前提点 * @param stack 当前路径的节点顺序 * @param sp 当前路径的路径顺序 */ public void search(int start, int v, Stack&lt;Integer&gt; stack, Stack&lt;Edge&gt; sp) &#123; LinkedList&lt;Edge&gt; list = edgeList[v]; boolean anotherWay = false; for (Edge w : list) &#123; if (!w.isSearched &amp;&amp; !w.isTheSameTo(v, w.getAnotherV(v), getPath(sp))) &#123; anotherWay = true; w.isSearched = true; stack.push(w.getAnotherV(v)); updateMax(sp.size()); sp.push(w); search(start, w.getAnotherV(v), stack, sp); &#125; &#125; if (!anotherWay) &#123; System.out.println(\"最长：===============================\"); rollback(start, stack, sp); &#125; &#125; /** * 回滚，回滚当上一个节点，如果当前节点有可以使用的边，调用搜索，如果没有，递归继续回滚 * 如果需要递归回滚，回滚到第二级之前，清空所有,当前路径下，从该点出发的方向 * 被回滚的路径，需要保存路径方向，以及提前路径 * @param stack 当前路径的节点顺序 * @param sp 当前路径的路径顺序 */ public void rollback(int start, Stack&lt;Integer&gt; stack, Stack&lt;Edge&gt; sp) &#123; String ss = getPath(sp); String output = \"顶点：\" + stack.toString() + NEWLINE + \"路径：\" + ss + NEWLINE; System.out.println(output); Edge e = sp.pop(); //需要回滚的路径 String pp = getPath(sp); //前提路径 int vz = stack.pop(); int vy = stack.peek(); boolean rollbakc2 = true; LinkedList&lt;Edge&gt; l = edgeList[vy]; //判断当前节点是否存在空闲路径，是否要回滚两级 //空闲路径：没有被正向搜索，也没有被缓存当前前提路径下，从改节点出发的方向 for (Edge w : l) &#123; if (!w.isSearched &amp;&amp; !w.isTheSameTo(vy, w.getAnotherV(vy), pp)) &#123; rollbakc2 = false; break; &#125; &#125; //回滚当前路径，回滚一级 int r = vy; for (Edge w : l) &#123; if (w.equals(e)) &#123; w.addTo(vy, vz, pp); w.isSearched = false; break; &#125; &#125; if (rollbakc2) &#123; //回滚两级, 清空所有,当前路径下，从该点出发的方向 for (Edge w : l) &#123; if (!w.isSearched &amp;&amp; w.isFrom(vy, pp)) &#123; w.removeTo(vy, w.getAnotherV(vy), pp); &#125; &#125; rollback(start, stack, sp); &#125; search(start, r, stack, sp); &#125; public String getPath(Stack&lt;Edge&gt; stack) &#123; String s = \"\"; for (Edge x : stack) &#123; s = s + x.id + PATH_SEPARATOR; &#125; s = s.replaceAll(PATH_SEPARATOR + \"$\", \"\"); return s; &#125; public static void main(String[] args) &#123; int[][] aa = new int[][]&#123;&#123;0, 1&#125;, &#123;0, 1&#125;, &#123;0, 3&#125;, &#123;1, 3&#125;, &#123;1, 2&#125;, &#123;1, 2&#125;, &#123;2, 3&#125;&#125;; Graph g = new Graph(4, aa.length); g.addEdge(aa); System.out.println(g.toString()); System.out.println(g.isEuler()); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://blog.dajitui.fun/categories/algorithm/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://blog.dajitui.fun/tags/algorithm/"},{"name":"欧拉","slug":"欧拉","permalink":"http://blog.dajitui.fun/tags/欧拉/"}]}]}